//api to retrive cve json data from
api_base_url = "https://cve.circl.lu/api/cve/"

//Try local cache, if it misses send request to the api
class CVEDetailsFetcher {
  constructor() {
    this.cache = new CVELocalStorageCache
    this.api_handler = new CVEApiHandler(api_base_url)
    console.log("New details fetcher")
  }

  get(cve_id, callback) {
    console.log("Attempting to get " + cve_id)
    this.cache.get(cve_id, (result) => {

      //Empty dict returned if cache misses
      if (!result || Object.keys(result).length === 0) {
        console.log("Cache missed for " + cve_id)

        //Not in cache, so retrieve from the api
        this.api_handler.get(cve_id, callback)
      } else {

        //cache hit, return from cache
        console.log("Local cache hit! (" + cve_id + ")")
        callback(result)
      }
    })
  }
}


function getBrowser() {
  if (typeof chrome !== "undefined") {
    if (typeof browser !== "undefined") {
      return "Firefox";
    } else {
      return "Chrome";
    }
  } else {
    return "Edge";
  }
}

//Manage browser local storage
class CVELocalStorageCache {
  constructor() {
    let bws = getBrowser()
    console.log(bws)
    switch(bws){
      case "Chrome":
        self.browser = chrome
        break;
      case "Firefox":
        self.browser = browser
      default:
        self.browser = browser
    }
   }
  get(cve_id, callback) {
    self.browser.storage.local.get([cve_id], (result) => {
      console.log("Local cache checked for " + cve_id)
      callback(result)
    })
  }

  set(cve_id, value) {
    self.browser.storage.local.set({ cve_id: value }, () => { 
      console.log("Local cache set for " + cve_id)
    })
  }
}


//handle requests to api
class CVEApiHandler {
  constructor(api_base_url) {
    this.cache = new CVELocalStorageCache
    this.base_url = api_base_url
  }

  //retrieve data and call the callback
  get(cve_id, callback) {
    console.log("Making api request for " + cve_id)
    fetch(this.base_url + cve_id)
      .then(response => response.json())
      .then(response => { 
        this.cache.set(cve_id, response)
        callback(response) 
      })
  }
}

//message listener from injected js
chrome.runtime.onMessage.addListener(
  (request, sender, sendResponse) => {
    switch (request.type) {
      case 'cve_details':
        let f = new CVEDetailsFetcher
        console.log(request.options.message)
        //retrieve and respond with cve details
        f.get(request.options.message, (response) => { 
          console.log(response)
          sendResponse(response)
        })
        break;
      default:
        break;
    }

    //means message response will be given asynchronously, keeps the port open
    return true;
  });